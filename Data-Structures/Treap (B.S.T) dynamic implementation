#include <bits/stdc++.h>

using namespace std;

class randomGenerator
{
public:

    std::mt19937 generator;

    randomGenerator()
    {
        unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
        generator = mt19937(seed);
    }

    int getRandomInt()
    {
        return generator();
    }

} generator;

template <typename dataType> ///only integers
class Treap
{
private:

    class Node
    {
    public:
        dataType key;
        dataType sumArb;
        int priority;
        unsigned int size;

        Node *l, *r;

        Node() : key(), sumArb(), priority(), size(), l(), r() {
        }

        Node(const dataType k) : key(k), sumArb(k), priority(generator.getRandomInt()), size(1), l(nullptr), r(nullptr) {
        }

        void update()
        {
            this->size = 1;
            this->sumArb = this->key;

            if (this->l != nullptr)
            {
                this->size += this->l->size;
                this->sumArb += this->l->sumArb;
            }

            if (this->r != nullptr)
            {
                this->size += this->r->size;
                this->sumArb += this->r->sumArb;
            }
        }
    };

    Node* join(Node *L, Node *R)
    {
        if (L == nullptr)
            return R;

        if (R == nullptr)
            return L;

        if (L->priority < R->priority) ///min-heap
        {
            L->r = join(L->r, R);
            L->update();

            return L;
        }
        else
        {
            R->l = join(L, R->l);
            R->update();

            return R;
        }
    }

    void split(Node *T, Node *&L, Node *&R, const dataType &key)
    {
        L = nullptr;
        R = nullptr;

        if (T == nullptr)
            return;

        if (T->key < key)
        {
            split(T->r, T->r, R, key);
            L = T;
        }
        else
        {
            split(T->l, L, T->l, key);
            R = T;
        }

        T->update();
    }

    bool find(Node *T, const dataType &key) const
    {
        if (T == nullptr)
            return false;

        if (T->key == key)
            return true;

        if (key < T->key)
            return find(T->l, key);
        else
            return find(T->r, key);
    }

    dataType kth_element(Node *T, const unsigned int position) const
    {
        assert(T != nullptr);

        if (realSize(T->l) + 1 == position)
            return T->key;
        else if (position <= realSize(T->l))
            return kth_element(T->l, position);
        else
            return kth_element(T->r, position - realSize(T->l) - 1);
    }

    vector<dataType> print(Node *T) const
    {
        if (T == nullptr)
            return vector<dataType>();

        vector<dataType> a = print(T->l);
        a.push_back(T->key);
        vector<dataType> b = print(T->r);

        for (auto it : b)
            a.push_back(it);

        return a;
    }

    unsigned int realSize(Node *T) const
    {
        if (T == nullptr)
            return 0;
        else
            return T->size;
    }

    void clear(Node *&T)
    {
        if (T == nullptr)
            return;

        clear(T->l);
        clear(T->r);

        delete T;
        T = nullptr;
    }

    void clearOnce(Node *&T)
    {
        if (T->l == nullptr && T->r == nullptr)
        {
            delete T;
            T = nullptr;
        }
        else
        {
            Node *aux = T;

            while (aux->l != nullptr)
                aux = aux->l;

            aux->key = numeric_limits<dataType>::min();

            Node *L, *R;
            split(T, L, R, numeric_limits<dataType>::min() + 1);

            assert(L != nullptr);

            clear(L);
            T = R;
        }
    }

    dataType sumSmallerOrEqual(const dataType &key)
    {
        Node *L, *M, *R;

        split(root, L, M, key);
        split(M, M, R, key + 1);

        dataType answer = 0;

        if (L != nullptr)
            answer += L->sumArb;

        if (M != nullptr)
            answer += M->sumArb;

        L = join(L, M);
        root = join(L, R);

        return answer;
    }

    Node *root;

public:

    Treap() : root(nullptr) {
    }

    Treap(const Treap &T) : root(nullptr)
    {
        vector<dataType> arr = T.print();

        for (const auto it : arr)
            this->root(it);
    }

    Treap(const vector<dataType> &arr) : root(nullptr)
    {
        for (const dataType it : arr)
            this->insert(it);
    }

    ~Treap()
    {
        this->clear(root);
    }

    Treap& operator = (const Treap &T)
    {
        this->clear(root);

        vector<dataType> arr = T.print();

        for (const auto it : arr)
            this->insert(it);

        return *this;
    }

    void insert(const dataType &key)
    {
        Node *L, *R;

        split(root, L, R, key);
        root = join(join(L, new Node(key)), R);
    }

    void eraseAll(const dataType &key) ///all instances
    {
        Node *L, *M, *R;

        split(root, L, M, key);
        split(M, M, R, key + 1);

        clear(M);

        root = join(L, R);
    }

    void eraseOnce(const dataType &key)
    {
        Node *L, *M, *R;

        split(root, L, M, key);
        split(M, M, R, key + 1);

        clearOnce(M);

        L = join(L, M);
        root = join(L, R);
    }

    unsigned int count(const dataType &key)
    {
        Node *L, *M, *R;

        split(root, L, M, key);
        split(M, M, R, key + 1);

        unsigned int answer = realSize(M);

        L = join(L, M);
        root = join(L, R);

        return answer;
    }

    unsigned int countSmaller(const dataType &key)
    {
        Node *L, *M, *R;

        split(root, L, M, key);
        split(M, M, R, key + 1);

        unsigned int answer = realSize(L);

        L = join(L, M);
        root = join(L, R);

        return answer;
    }

    unsigned int countSmallerOrEqual(const dataType &key)
    {
        Node *L, *M, *R;

        split(root, L, M, key);
        split(M, M, R, key + 1);

        unsigned int answer = realSize(L) + realSize(M);

        L = join(L, M);
        root = join(L, R);

        return answer;
    }

    unsigned int countGreater(const dataType &key)
    {
        return this->size() - this->countSmallerOrEqual(key);
    }

    dataType sumRange(const dataType &x, const dataType &y)
    {
        return sumSmallerOrEqual(y) - sumSmallerOrEqual(x - 1);
    }

    bool find(const dataType &key) const
    {
        return find(root, key);
    }

    dataType kth_element(const unsigned int position) const
    {
        assert(1 <= position && position <= realSize(root));

        return kth_element(root, position);
    }

    dataType operator [] (const unsigned int position) const
    {
        return kth_element(position);
    }

    vector<dataType> print() const
    {
        return this->print(root);
    }

    bool empty() const
    {
        return this->root == nullptr;
    }

    unsigned int size() const
    {
        return realSize(root);
    }
};

int main()
{

    return 0;
}
